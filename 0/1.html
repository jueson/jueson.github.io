<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPå»¶è¿Ÿæµ‹è¯•å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .description {
            font-size: 14px;
            opacity: 0.8;
        }

        .modules {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }

        .module {
            flex: 1;
            min-width: 300px;
            background: #f9f9f9;
            border-radius: 6px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }

        textarea, input, select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
            font-family: monospace;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .results-container {
            margin-top: 20px;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .results-list {
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
        }

        .result-item {
            padding: 10px;
            border-bottom: 1px solid #e0e0e0;
            font-family: monospace;
            font-size: 14px;
        }

        .result-item:nth-child(even) {
            background: #f9f9f9;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .status.info {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .test-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .progress {
            width: 100%;
            height: 6px;
            background: #f0f0f0;
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #3498db;
            width: 0%;
            transition: width 0.3s;
        }

        .hidden {
            display: none;
        }

        .ip-source-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .ip-source-controls input {
            flex: 1;
        }

        .source-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .source-buttons button {
            flex: 1;
        }

        @media (max-width: 768px) {
            .modules {
                flex-direction: column;
            }

            .module {
                min-width: 100%;
            }

            .ip-source-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>IPå»¶è¿Ÿæµ‹è¯•å·¥å…·</h1>
            <p class="description">æ˜¾ç¤ºæœ€ä½³20ä¸ªç»“æœï¼Œå¯ä¸‹è½½æ‰€æœ‰æœ‰æ•ˆIP</p>
        </header>

        <div class="modules">
            <div class="module">
                <h2>é…ç½®è®¾ç½®</h2>

                <div class="form-group">
                    <label for="ipSource">IPæ¥æº</label>
                    <select id="ipSource">
                        <option value="manual">æ‰‹åŠ¨è¾“å…¥</option>
                        <option value="cfRandom">CFéšæœºIP</option>
                        <option value="urlFetch">URLè·å–</option>
                    </select>
                </div>

                <div id="manualInputDiv" class="form-group">
                    <label for="ipList">IPåˆ—è¡¨ï¼ˆæ¯è¡Œä¸€ä¸ªï¼Œæ ¼å¼ï¼šIP:ç«¯å£#æè¿°ï¼‰</label>
                    <textarea id="ipList" placeholder="ä¾‹å¦‚ï¼š
104.21.26.58:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ è¥¿é›…å›¾
173.245.58.95:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ æ´›æ‰çŸ¶
51.178.141.36:8443#ğŸ‡«ğŸ‡«ğŸ‡·ğŸ‡· å·´é»æˆ´é«˜ä¹"></textarea>
                </div>

                <div id="cfRandomDiv" class="form-group hidden">
                    <div class="ip-source-controls">
                        <div>
                            <label for="randomIPCount">ç”Ÿæˆæ•°é‡</label>
                            <input type="number" id="randomIPCount" value="20" min="1" max="100">
                        </div>
                        <div>
                            <label for="cfPort">ç«¯å£</label>
                            <input type="number" id="cfPort" value="443" min="1" max="65535">
                        </div>
                    </div>
                    <button id="generateCFIPBtn">ç”ŸæˆCFéšæœºIP</button>
                </div>

                <div id="urlFetchDiv" class="form-group hidden">
                    <label for="fetchURLInput">è·å–URL</label>
                    <input type="text" id="fetchURLInput" placeholder="ä¾‹å¦‚ï¼šhttps://raw.githubusercontent.com/example/ips.txt">
                    <button id="fetchIPBtn">è·å–IP</button>
                    <small>å¤åˆ¶ä»¥ä¸‹åœ°å€ç²˜è´´è·å–</small>
                    <small>https://www.jueson.qzz.io/0/ip01.txt</small>
                    <small>https://www.jueson.qzz.io/0/ip02.txt</small>
                    <small>https://www.jueson.qzz.io/0/ip03.txt</small>
                    <small>https://www.jueson.qzz.io/0/ip04.txt</small>
                    <small>https://www.jueson.qzz.io/0/ip05.txt</small>
                </div>

                <div class="form-group">
                    <label for="testUrl">è‡ªå®šä¹‰æµ‹è¯•URLï¼ˆå¯é€‰ï¼‰</label>
                    <input type="text" id="testUrl" placeholder="ä¾‹å¦‚ï¼šhttps://your-test-endpoint.com/test">
                    <small>ç•™ç©ºä½¿ç”¨é»˜è®¤æµ‹è¯•æ–¹æ³•</small>
                </div>

                <div class="form-group">
                    <label for="threads">å¹¶å‘çº¿ç¨‹æ•°</label>
                    <input type="number" id="threads" value="5" min="1" max="50">
                </div>

                <div class="button-group">
                    <button id="startTest">å¼€å§‹æµ‹è¯•</button>
                    <button id="clearResults">æ¸…ç©ºç»“æœ</button>
                </div>
            </div>

            <div class="module">
                <h2>æµ‹è¯•çŠ¶æ€</h2>
                <div id="statusMessage" class="status info">å‡†å¤‡å¼€å§‹æµ‹è¯•</div>

                <div class="progress">
                    <div id="progressBar" class="progress-bar"></div>
                </div>

                <div class="test-controls">
                    <button id="stopTest" disabled>åœæ­¢æµ‹è¯•</button>
                    <button id="downloadResults" class="hidden">ä¸‹è½½æ‰€æœ‰æœ‰æ•ˆIP</button>
                </div>
            </div>
        </div>

        <div class="module">
            <div class="results-header">
                <h2>æµ‹è¯•ç»“æœï¼ˆæŒ‰å»¶è¿Ÿæ’åºï¼Œæ˜¾ç¤ºå‰20ä¸ªï¼‰</h2>
                <span id="resultCount">0 ä¸ªç»“æœ</span>
            </div>

            <div class="results-container">
                <div id="resultsList" class="results-list">
                    <div class="result-item">æš‚æ— æµ‹è¯•ç»“æœ</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // è·å–DOMå…ƒç´ 
            const ipSourceSelect = document.getElementById('ipSource');
            const manualInputDiv = document.getElementById('manualInputDiv');
            const cfRandomDiv = document.getElementById('cfRandomDiv');
            const urlFetchDiv = document.getElementById('urlFetchDiv');
            const ipListTextarea = document.getElementById('ipList');
            const randomIPCountInput = document.getElementById('randomIPCount');
            const cfPortInput = document.getElementById('cfPort');
            const fetchURLInput = document.getElementById('fetchURLInput');
            const generateCFIPBtn = document.getElementById('generateCFIPBtn');
            const fetchIPBtn = document.getElementById('fetchIPBtn');
            const testUrlInput = document.getElementById('testUrl');
            const threadsInput = document.getElementById('threads');
            const startTestButton = document.getElementById('startTest');
            const stopTestButton = document.getElementById('stopTest');
            const clearResultsButton = document.getElementById('clearResults');
            const downloadResultsButton = document.getElementById('downloadResults');
            const statusMessage = document.getElementById('statusMessage');
            const progressBar = document.getElementById('progressBar');
            const resultsList = document.getElementById('resultsList');
            const resultCount = document.getElementById('resultCount');

            // æµ‹è¯•çŠ¶æ€å˜é‡
            let isTesting = false;
            let testAbortController = null;
            let testResults = [];

            // CF CIDRåˆ—è¡¨
            const CF_CIDR_LIST = [
                '173.245.48.0/20', '103.21.244.0/22', '103.22.200.0/22', '103.31.4.0/22',
                '141.101.64.0/18', '108.162.192.0/18', '190.93.240.0/20', '188.114.96.0/20',
                '197.234.240.0/22', '198.41.128.0/17', '162.158.0.0/15', '104.16.0.0/13',
                '104.24.0.0/14', '172.64.0.0/13', '131.0.72.0/22'
            ];

            // ç¤ºä¾‹IPåˆ—è¡¨
            const exampleIPs = `104.21.26.58:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ è¥¿é›…å›¾
173.245.58.95:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ æ´›æ‰çŸ¶
51.178.141.36:8443#ğŸ‡«ğŸ‡«ğŸ‡·ğŸ‡· å·´é»æˆ´é«˜ä¹
104.16.223.254:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ åœ£ä½•å¡
172.67.70.71:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ çº½çº¦
104.28.14.11:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ èŠåŠ å“¥
104.31.16.35:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ è¾¾æ‹‰æ–¯
104.18.34.23:443#ğŸ‡ºğŸ‡ºğŸ‡¸ğŸ‡¸ äºšç‰¹å…°å¤§`;

            // è®¾ç½®ç¤ºä¾‹IPåˆ—è¡¨
            ipListTextarea.value = exampleIPs;

            // IPæ¥æºé€‰æ‹©äº‹ä»¶
            ipSourceSelect.addEventListener('change', function() {
                const value = this.value;
                manualInputDiv.classList.toggle('hidden', value !== 'manual');
                cfRandomDiv.classList.toggle('hidden', value !== 'cfRandom');
                urlFetchDiv.classList.toggle('hidden', value !== 'urlFetch');
            });

            // ç”ŸæˆCFéšæœºIPæŒ‰é’®ç‚¹å‡»äº‹ä»¶
            generateCFIPBtn.addEventListener('click', generateCFRandomIPs);

            // è·å–IPæŒ‰é’®ç‚¹å‡»äº‹ä»¶
            fetchIPBtn.addEventListener('click', fetchIPsFromURL);

            // å¼€å§‹æµ‹è¯•æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            startTestButton.addEventListener('click', startTest);

            // åœæ­¢æµ‹è¯•æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            stopTestButton.addEventListener('click', stopTest);

            // æ¸…ç©ºç»“æœæŒ‰é’®ç‚¹å‡»äº‹ä»¶
            clearResultsButton.addEventListener('click', clearResults);

            // ä¸‹è½½ç»“æœæŒ‰é’®ç‚¹å‡»äº‹ä»¶
            downloadResultsButton.addEventListener('click', downloadResults);

            // ç”ŸæˆCFéšæœºIPå‡½æ•°
            function generateCFRandomIPs() {
                const count = parseInt(randomIPCountInput.value) || 20;
                const port = cfPortInput.value || '443';

                if (count < 1 || count > 100) {
                    showStatus('ç”Ÿæˆæ•°é‡å¿…é¡»åœ¨1-100ä¹‹é—´', 'error');
                    return;
                }

                const ips = [];
                for (let i = 0; i < count; i++) {
                    const cidr = CF_CIDR_LIST[Math.floor(Math.random() * CF_CIDR_LIST.length)];
                    const ip = generateRandomIPFromCIDR(cidr);
                    ips.push(ip + ':' + port);
                }

                // åˆ‡æ¢åˆ°æ‰‹åŠ¨è¾“å…¥æ¨¡å¼å¹¶å¡«å……ç»“æœ
                ipSourceSelect.value = 'manual';
                manualInputDiv.classList.remove('hidden');
                cfRandomDiv.classList.add('hidden');
                urlFetchDiv.classList.add('hidden');

                ipListTextarea.value = ips.join('\n');
                showStatus(`å·²ç”Ÿæˆ ${count} ä¸ªCFéšæœºIP`, 'info');
            }

            // ä»CIDRç”ŸæˆéšæœºIP
            function generateRandomIPFromCIDR(cidr) {
                const [baseIP, prefixLength] = cidr.split('/');
                const prefix = parseInt(prefixLength);
                const hostBits = 32 - prefix;
                const ipParts = baseIP.split('.').map(p => parseInt(p));
                const ipInt = (ipParts[0] << 24) | (ipParts[1] << 16) | (ipParts[2] << 8) | ipParts[3];
                const randomOffset = Math.floor(Math.random() * Math.pow(2, hostBits));
                const mask = (0xFFFFFFFF << hostBits) >>> 0;
                const randomIP = (((ipInt & mask) >>> 0) + randomOffset) >>> 0;
                return [(randomIP >>> 24) & 0xFF, (randomIP >>> 16) & 0xFF, (randomIP >>> 8) & 0xFF, randomIP & 0xFF].join('.');
            }

            // ä»URLè·å–IPå‡½æ•°
            async function fetchIPsFromURL() {
                const url = fetchURLInput.value.trim();
                if (!url) {
                    showStatus('è¯·è¾“å…¥URL', 'error');
                    return;
                }

                fetchIPBtn.disabled = true;
                fetchIPBtn.textContent = 'è·å–ä¸­...';

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const text = await response.text();
                    const ipLines = text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line && !line.startsWith('#'));

                    if (ipLines.length === 0) {
                        showStatus('æœªè·å–åˆ°æœ‰æ•ˆIP', 'error');
                        return;
                    }

                    // åˆ‡æ¢åˆ°æ‰‹åŠ¨è¾“å…¥æ¨¡å¼å¹¶å¡«å……ç»“æœ
                    ipSourceSelect.value = 'manual';
                    manualInputDiv.classList.remove('hidden');
                    cfRandomDiv.classList.add('hidden');
                    urlFetchDiv.classList.add('hidden');

                    ipListTextarea.value = ipLines.join('\n');
                    showStatus(`å·²è·å– ${ipLines.length} ä¸ªIP`, 'info');
                } catch (error) {
                    showStatus(`è·å–å¤±è´¥: ${error.message}`, 'error');
                } finally {
                    fetchIPBtn.disabled = false;
                    fetchIPBtn.textContent = 'è·å–IP';
                }
            }

            // å¼€å§‹æµ‹è¯•å‡½æ•°
            function startTest() {
                if (isTesting) return;

                // è·å–IPåˆ—è¡¨
                let ipEntries = [];
                const ipSource = ipSourceSelect.value;

                if (ipSource === 'manual') {
                    // è§£ææ‰‹åŠ¨è¾“å…¥çš„IPåˆ—è¡¨
                    const ipListText = ipListTextarea.value.trim();
                    if (!ipListText) {
                        showStatus('è¯·è¾“å…¥IPåˆ—è¡¨', 'error');
                        return;
                    }

                    ipEntries = parseIPList(ipListText);
                } else if (ipSource === 'cfRandom') {
                    // ç”ŸæˆCFéšæœºIP
                    const count = parseInt(randomIPCountInput.value) || 20;
                    const port = cfPortInput.value || '443';

                    if (count < 1 || count > 100) {
                        showStatus('ç”Ÿæˆæ•°é‡å¿…é¡»åœ¨1-100ä¹‹é—´', 'error');
                        return;
                    }

                    const ips = [];
                    for (let i = 0; i < count; i++) {
                        const cidr = CF_CIDR_LIST[Math.floor(Math.random() * CF_CIDR_LIST.length)];
                        const ip = generateRandomIPFromCIDR(cidr);
                        ips.push(ip + ':' + port);
                    }

                    ipEntries = parseIPList(ips.join('\n'));
                } else if (ipSource === 'urlFetch') {
                    showStatus('è¯·å…ˆä½¿ç”¨"è·å–IP"æŒ‰é’®è·å–IPåˆ—è¡¨', 'error');
                    return;
                }

                if (ipEntries.length === 0) {
                    showStatus('æ²¡æœ‰æœ‰æ•ˆçš„IPæ¡ç›®', 'error');
                    return;
                }

                // è·å–æµ‹è¯•URL
                const testUrl = testUrlInput.value.trim();

                // è·å–çº¿ç¨‹æ•°
                const threads = parseInt(threadsInput.value) || 5;
                if (threads < 1 || threads > 50) {
                    showStatus('çº¿ç¨‹æ•°å¿…é¡»åœ¨1-50ä¹‹é—´', 'error');
                    return;
                }

                // æ›´æ–°UIçŠ¶æ€
                isTesting = true;
                startTestButton.disabled = true;
                stopTestButton.disabled = false;
                testResults = [];
                updateResultsDisplay();

                // åˆ›å»ºä¸­æ­¢æ§åˆ¶å™¨
                testAbortController = new AbortController();

                // å¼€å§‹æµ‹è¯•
                showStatus(`å¼€å§‹æµ‹è¯• ${ipEntries.length} ä¸ªIP...`, 'info');
                progressBar.style.width = '0%';

                runLatencyTest(ipEntries, testUrl, threads, testAbortController.signal)
                    .then(results => {
                        if (!testAbortController.signal.aborted) {
                            testResults = results;
                            updateResultsDisplay();
                            showStatus(`æµ‹è¯•å®Œæˆï¼Œå…±æµ‹è¯• ${results.length} ä¸ªIP`, 'info');
                            downloadResultsButton.classList.remove('hidden');
                        }
                    })
                    .catch(error => {
                        if (!testAbortController.signal.aborted) {
                            showStatus(`æµ‹è¯•å‡ºé”™: ${error.message}`, 'error');
                        }
                    })
                    .finally(() => {
                        isTesting = false;
                        startTestButton.disabled = false;
                        stopTestButton.disabled = true;
                        progressBar.style.width = '100%';
                    });
            }

            // è§£æIPåˆ—è¡¨
            function parseIPList(ipListText) {
                const ipLines = ipListText.split('\n').filter(line => line.trim());
                const ipEntries = [];

                for (const line of ipLines) {
                    const parts = line.split('#');
                    if (parts.length < 1) continue;

                    const ipPort = parts[0].trim();
                    const description = parts.length > 1 ? parts[1].trim() : '';

                    // éªŒè¯IP:ç«¯å£æ ¼å¼
                    const ipPortRegex = /^([\d.]+|[\da-fA-F:]+):(\d+)$/;
                    if (!ipPortRegex.test(ipPort)) {
                        showStatus(`æ— æ•ˆçš„IPæ ¼å¼: ${ipPort}`, 'error');
                        return [];
                    }

                    ipEntries.push({
                        ipPort: ipPort,
                        description: description
                    });
                }

                return ipEntries;
            }

            // åœæ­¢æµ‹è¯•å‡½æ•°
            function stopTest() {
                if (isTesting && testAbortController) {
                    testAbortController.abort();
                    isTesting = false;
                    startTestButton.disabled = false;
                    stopTestButton.disabled = true;
                    showStatus('æµ‹è¯•å·²åœæ­¢', 'warning');
                }
            }

            // æ¸…ç©ºç»“æœå‡½æ•°
            function clearResults() {
                testResults = [];
                updateResultsDisplay();
                downloadResultsButton.classList.add('hidden');
                showStatus('ç»“æœå·²æ¸…ç©º', 'info');
            }

            // ä¸‹è½½ç»“æœå‡½æ•° - ä¿®æ”¹ä¸ºä¸‹è½½æ‰€æœ‰æœ‰æ•ˆIP
            function downloadResults() {
                if (testResults.length === 0) {
                    showStatus('æ²¡æœ‰ç»“æœå¯ä¸‹è½½', 'error');
                    return;
                }

                // è·å–æ‰€æœ‰æœ‰æ•ˆç»“æœï¼ˆå»¶è¿Ÿ>=0ï¼‰
                const validResults = getAllValidResults();

                if (validResults.length === 0) {
                    showStatus('æ²¡æœ‰æœ‰æ•ˆçš„IPç»“æœå¯ä¸‹è½½', 'error');
                    return;
                }

                // åˆ›å»ºè¦ä¸‹è½½çš„å†…å®¹
                let content = '';
                for (const result of validResults) {
                    content += `${result.ipPort}#[${result.description}] ${result.latency}ms\n`;
                }

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // æ·»åŠ æ—¶é—´æˆ³åˆ°æ–‡ä»¶å
                const now = new Date();
                const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
                a.download = `ip_latency_results_${timestamp}.txt`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatus(`å·²ä¸‹è½½ ${validResults.length} ä¸ªæœ‰æ•ˆIPç»“æœ`, 'info');
            }

            // è¿è¡Œå»¶è¿Ÿæµ‹è¯•
            async function runLatencyTest(ipEntries, testUrl, threads, signal) {
                const results = [];
                const total = ipEntries.length;
                let completed = 0;

                // åˆ†æ‰¹å¤„ç†
                for (let i = 0; i < total; i += threads) {
                    if (signal.aborted) break;

                    const batch = ipEntries.slice(i, Math.min(i + threads, total));
                    const promises = batch.map(entry => testLatency(entry, testUrl, signal));

                    const batchResults = await Promise.all(promises);
                    results.push(...batchResults.filter(r => r !== null));

                    completed += batch.length;
                    const progress = (completed / total) * 100;
                    progressBar.style.width = `${progress}%`;

                    showStatus(`æµ‹è¯•è¿›åº¦: ${completed}/${total} (${Math.round(progress)}%)`, 'info');
                }

                return results;
            }

            // æµ‹è¯•å•ä¸ªIPçš„å»¶è¿Ÿ
            async function testLatency(ipEntry, testUrl, signal) {
                try {
                    const startTime = Date.now();

                    // å¦‚æœæœ‰è‡ªå®šä¹‰æµ‹è¯•URLï¼Œä½¿ç”¨å®ƒ
                    if (testUrl) {
                        // æ›¿æ¢URLä¸­çš„å ä½ç¬¦
                        const [ip, port] = ipEntry.ipPort.split(':');
                        const testEndpoint = testUrl.replace('{ip}', ip).replace('{port}', port);

                        const response = await fetch(testEndpoint, {
                            method: 'GET',
                            signal: signal,
                            cache: 'no-cache'
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                    } else {
                        // ä½¿ç”¨é»˜è®¤æµ‹è¯•æ–¹æ³•ï¼ˆæ¨¡æ‹Ÿå»¶è¿Ÿï¼‰
                        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥æ›¿æ¢ä¸ºçœŸå®çš„å»¶è¿Ÿæµ‹è¯•é€»è¾‘
                        await new Promise(resolve => {
                            setTimeout(resolve, Math.random() * 1000 + 100);
                        });
                    }

                    const latency = Date.now() - startTime;

                    return {
                        ...ipEntry,
                        latency: latency,
                        timestamp: new Date().toISOString()
                    };
                } catch (error) {
                    if (signal.aborted) {
                        return null;
                    }

                    console.error(`æµ‹è¯• ${ipEntry.ipPort} å¤±è´¥:`, error);
                    return {
                        ...ipEntry,
                        latency: -1,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            // è·å–å‰Nä¸ªç»“æœï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
            function getTopResults(n) {
                // è¿‡æ»¤æ‰å¤±è´¥çš„ç»“æœ
                const validResults = testResults.filter(r => r.latency >= 0);

                // æŒ‰å»¶è¿Ÿæ’åº
                validResults.sort((a, b) => a.latency - b.latency);

                // è¿”å›å‰Nä¸ª
                return validResults.slice(0, n);
            }

            // è·å–æ‰€æœ‰æœ‰æ•ˆç»“æœï¼ˆç”¨äºä¸‹è½½ï¼‰
            function getAllValidResults() {
                // è¿‡æ»¤æ‰å¤±è´¥çš„ç»“æœ
                const validResults = testResults.filter(r => r.latency >= 0);

                // æŒ‰å»¶è¿Ÿæ’åº
                validResults.sort((a, b) => a.latency - b.latency);

                return validResults;
            }

            // æ›´æ–°ç»“æœæ˜¾ç¤º
            function updateResultsDisplay() {
                const topResults = getTopResults(20);

                if (topResults.length === 0) {
                    resultsList.innerHTML = '<div class="result-item">æš‚æ— æµ‹è¯•ç»“æœ</div>';
                    resultCount.textContent = '0 ä¸ªç»“æœ';
                    return;
                }

                let html = '';
                for (const result of topResults) {
                    html += `<div class="result-item">${result.ipPort}#[${result.description}] ${result.latency}ms</div>`;
                }

                resultsList.innerHTML = html;
                resultCount.textContent = `${topResults.length} ä¸ªç»“æœï¼ˆå…± ${testResults.length} ä¸ªIPï¼Œ${getAllValidResults().length} ä¸ªæœ‰æ•ˆï¼‰`;
            }

            // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
            function showStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = 'status ' + type;
            }
        });
    </script>
</body>
</html>